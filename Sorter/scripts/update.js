const fs = require('fs').promises;
const path = require('path');
const ffmpeg = require('fluent-ffmpeg');

// Configuration - process files from sorted directories instead of unsorted
const SOURCE_DIRS = {
  masks: path.resolve(__dirname, '../files/videos/masks'),
  segments: path.resolve(__dirname, '../files/videos/segments'),
};
const DEST_DIRS = {
  data: {
    masks: path.resolve(__dirname, '../data/masks.json'),
    segments: path.resolve(__dirname, '../data/segments.json'),
  },
};

// Utility Functions
async function initializeJsonFile(filePath) {
  try {
    const stats = await fs.stat(filePath);
    if (stats.size === 0) {
      await fs.writeFile(filePath, '[]');
      console.log(`Initialized empty JSON file: ${filePath}`);
    }
  } catch (err) {
    if (err.code === 'ENOENT') {
      await fs.writeFile(filePath, '[]');
      console.log(`Created and initialized JSON file: ${filePath}`);
    } else {
      throw err;
    }
  }
}

async function getVideoMetadata(filePath) {
  return new Promise((resolve, reject) => {
    ffmpeg.ffprobe(filePath, (err, metadata) => {
      if (err) return reject(err);
      const stream = metadata.streams[0];
      resolve({
        duration: metadata.format.duration,
        width: stream.width,
        height: stream.height,
        frameRate: eval(stream.r_frame_rate),
        nbFrames: stream.nb_frames,
      });
    });
  });
}

function getOrientation(width, height) {
  return width > height ? 'landscape' : width < height ? 'portrait' : 'square';
}

/**
 * Calculate normalized aspect ratio where the smaller dimension comes first
 * and the larger dimension is always 1.
 * 
 * Examples:
 * - 1920x1080 (landscape) → [0.5625, 1] (smaller, larger)
 * - 1080x1920 (portrait)  → [0.5625, 1] (smaller, larger) 
 * - 1080x1080 (square)    → [1, 1] (both dimensions=1)
 * 
 * This creates a consistent "value map" where [smaller_ratio, larger_ratio]
 * can be used directly for scaling operations.
 */
function getRatio(width, height) {
  let ratio;
  if (width > height) {
    // Landscape: smaller dimension (height) first, larger (width) = 1
    ratio = [height / width, 1];
  } else if (height > width) {
    // Portrait: smaller dimension (width) first, larger (height) = 1
    ratio = [width / height, 1];
  } else {
    // Square: both dimensions are equal, so both become 1
    ratio = [1, 1];
  }
  return ratio.map(n => parseFloat(n.toFixed(4)));
}

// Main Processing Function - no file moving or thumbnail generation
async function processExistingVideo(filePath, clipType) {
  try {
    const filename = path.basename(filePath);
    const ext = path.extname(filename);
    const baseName = path.basename(filename, ext);

    console.log(`Processing existing video: ${filename} (${clipType})`);

    // Get metadata from existing video file
    const { duration, width, height, frameRate, nbFrames } = await getVideoMetadata(filePath);

    // Generate paths (files are already in place, thumbnails already exist)
    const thumbnailSrc = path.join('thumbnails', clipType, `${baseName}.png`).replace(/\\/g, '/');
    const clipSrc = path.join('videos', clipType, filename).replace(/\\/g, '/');

    // Create metadata object
    const metadata = {
      clipType,
      length: Math.round(duration),
      frames: parseInt(nbFrames, 10),
      mode: 'loop',
      orientation: getOrientation(width, height),
      width,
      height,
      ratio: getRatio(width, height),
      speedMin: 1,
      speedMax: 1.5,
      thumbnailSrc,
      clipSrc,
      enabled: true, // Default to enabled
      title: baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), // Generate friendly title from filename
    };

    // Update JSON
    const jsonPath = DEST_DIRS.data[clipType];
    await initializeJsonFile(jsonPath);
    const jsonData = JSON.parse(await fs.readFile(jsonPath));
    
    // Clean up any existing entries with wrong path format (with /files/ prefix)
    const correctClipSrc = clipSrc;
    const wrongClipSrc = `/files/${clipSrc}`;
    
    // Check if entry already exists (check both correct and incorrect formats)
    let existingEntryIndex = jsonData.findIndex((entry) => entry.clipSrc === correctClipSrc);
    let wrongEntryIndex = jsonData.findIndex((entry) => entry.clipSrc === wrongClipSrc);
    
    // If we found an entry with wrong format, remove it but preserve its custom settings
    let preservedSettings = {};
    if (wrongEntryIndex !== -1) {
      const wrongEntry = jsonData[wrongEntryIndex];
      const autoGeneratedTitle = baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      
      // Preserve custom settings from the wrong entry
      preservedSettings = {
        title: wrongEntry.title && wrongEntry.title !== autoGeneratedTitle ? wrongEntry.title : undefined,
        enabled: wrongEntry.enabled,
        customSpeedMin: wrongEntry.customSpeedMin,
        customSpeedMax: wrongEntry.customSpeedMax,
        isLooping: wrongEntry.isLooping,
        tags: wrongEntry.tags || [],
      };
      
      // Remove the wrong entry
      jsonData.splice(wrongEntryIndex, 1);
      console.log(`Removed entry with incorrect path format: ${wrongClipSrc}`);
      
      // Adjust index if needed
      if (wrongEntryIndex < existingEntryIndex) {
        existingEntryIndex -= 1;
      }
    }
    
    if (existingEntryIndex === -1) {
      // New entry - add it (merging any preserved settings)
      const finalMetadata = {
        ...metadata,
        title: preservedSettings.title || metadata.title,
        enabled: preservedSettings.enabled ?? metadata.enabled,
        customSpeedMin: preservedSettings.customSpeedMin ?? metadata.speedMin,
        customSpeedMax: preservedSettings.customSpeedMax ?? metadata.speedMax,
        isLooping: preservedSettings.isLooping ?? true,
        tags: preservedSettings.tags ?? [],
      };
      
      jsonData.push(finalMetadata);
      console.log(`Added new entry for ${filename}${preservedSettings.title ? ' (preserved custom settings)' : ''}`);
    } else {
      // Entry exists - update metadata but preserve custom settings
      const existingEntry = jsonData[existingEntryIndex];
      const autoGeneratedTitle = baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      
      // Preserve custom title if it's different from what would be auto-generated
      const shouldPreserveTitle = existingEntry.title && existingEntry.title !== autoGeneratedTitle;
      
      jsonData[existingEntryIndex] = {
        ...metadata,
        title: shouldPreserveTitle ? existingEntry.title : metadata.title,
        // Also preserve any custom settings
        enabled: existingEntry.enabled ?? metadata.enabled,
        customSpeedMin: existingEntry.customSpeedMin ?? metadata.speedMin,
        customSpeedMax: existingEntry.customSpeedMax ?? metadata.speedMax,
        isLooping: existingEntry.isLooping ?? true,
        tags: existingEntry.tags ?? [],
      };
      
      console.log(`Updated existing entry for ${filename} (preserved custom settings)`);
    }
    
    await fs.writeFile(jsonPath, JSON.stringify(jsonData, null, 2));

    console.log(`✅ Processed ${filename} (${clipType})`);
  } catch (err) {
    console.error(`❌ Error processing ${filePath}:`, err);
  }
}

async function main() {
  console.log('🔄 Starting update process for existing video files...\n');
  
  for (const clipType of Object.keys(SOURCE_DIRS)) {
    const sourceDir = SOURCE_DIRS[clipType];
    console.log(`📂 Processing ${clipType} from ${sourceDir}`);
    
    try {
      // Check if directory exists
      try {
        await fs.access(sourceDir);
      } catch (err) {
        console.log(`⚠️  Directory ${sourceDir} doesn't exist, skipping...`);
        continue;
      }
      
      const files = await fs.readdir(sourceDir);
      const videoFiles = files.filter(file => file.endsWith('.mp4'));
      
      if (videoFiles.length === 0) {
        console.log(`📭 No .mp4 files found in ${sourceDir}`);
        continue;
      }
      
      console.log(`📹 Found ${videoFiles.length} video files`);
      
      for (const file of videoFiles) {
        const filePath = path.join(sourceDir, file);
        await processExistingVideo(filePath, clipType);
      }
      
      console.log(`✅ Completed processing ${clipType}\n`);
    } catch (err) {
      console.error(`❌ Error reading directory ${sourceDir}:`, err);
    }
  }
  
  console.log('🎉 Update process completed!');
  console.log('\n💡 Tip: Run this script anytime you want to regenerate JSON metadata');
  console.log('   from existing video files without moving files or regenerating thumbnails.');
}

// Handle process interruption gracefully
process.on('SIGINT', () => {
  console.log('\n⏹️  Update process interrupted by user');
  process.exit(0);
});

main().catch(err => {
  console.error('💥 Fatal error:', err);
  process.exit(1);
});
